<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tournament Voting Platform</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/4.0.3/web3.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
            overflow-x: auto;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .wallet-section {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
        }

        .wallet-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .wallet-address {
            font-family: monospace;
            background: rgba(0, 0, 0, 0.2);
            padding: 10px 15px;
            border-radius: 8px;
            word-break: break-all;
        }

        .btn {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            border: none;
            padding: 12px 24px;
            color: white;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            font-size: 16px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 15px rgba(0,0,0,0.3);
        }

        .btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        .tournament-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .info-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        .bracket-container {
            background: rgba(255, 255, 255, 0.05);
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
            overflow-x: auto;
        }

        .bracket {
            display: flex;
            justify-content: center;
            align-items: center;
            min-width: 1200px;
            gap: 60px;
        }

        .round {
            display: flex;
            flex-direction: column;
            gap: 40px;
            min-width: 200px;
        }

        .round h3 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.2rem;
            color: #ffd700;
        }

        .match {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
            backdrop-filter: blur(10px);
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .match.active {
            border-color: #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        .match.finished {
            border-color: #4ecdc4;
        }

        .participant {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease;
            margin: 2px 0;
        }

        .participant:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .participant.winner {
            background: linear-gradient(45deg, #4ecdc4, #45b7b8);
            font-weight: bold;
        }

        .participant-name {
            font-weight: 600;
        }

        .votes {
            background: rgba(0, 0, 0, 0.3);
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.9rem;
            min-width: 40px;
            text-align: center;
        }

        .timer {
            position: absolute;
            top: 5px;
            right: 10px;
            background: rgba(255, 107, 107, 0.8);
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .timer.finished {
            background: rgba(76, 175, 80, 0.8);
        }

        .vote-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }

        .modal-content h3 {
            margin-bottom: 20px;
            color: #ffd700;
        }

        .vote-buttons {
            display: flex;
            gap: 15px;
            margin: 20px 0;
        }

        .vote-btn {
            flex: 1;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid transparent;
            border-radius: 10px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .vote-btn:hover {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.2);
        }

        .close-modal {
            background: #ff6b6b;
            margin-top: 15px;
        }

        .status-message {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .credit {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .credit a {
            color: #ffd700;
            text-decoration: none;
            font-weight: bold;
        }

        .credit a:hover {
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            .bracket {
                gap: 30px;
                min-width: 800px;
            }
            
            .round {
                min-width: 150px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üèÜ Tournament Voting Platform</h1>
            <p>Blockchain-powered voting system on Monad Testnet</p>
        </div>

        <div class="wallet-section">
            <div class="wallet-info">
                <div>
                    <strong>Wallet:</strong>
                    <div class="wallet-address" id="walletAddress">Not connected</div>
                </div>
                <div>
                    <strong>Balance:</strong> <span id="balance">0 MON</span>
                </div>
                <button class="btn" id="connectWallet">Connect Wallet</button>
            </div>
        </div>

        <div class="tournament-info">
            <div class="info-card">
                <h3>Current Round</h3>
                <div id="currentRound">Loading...</div>
            </div>
            <div class="info-card">
                <h3>Tournament Status</h3>
                <div id="tournamentStatus">Loading...</div>
            </div>
            <div class="info-card">
                <h3>Vote Cost</h3>
                <div>0.1 MON</div>
            </div>
            <div class="info-card">
                <h3>Total Participants</h3>
                <div>8</div>
            </div>
        </div>

        <div class="bracket-container">
            <div class="bracket" id="bracket">
                <!-- Bracket will be generated here -->
            </div>
        </div>

        <div class="status-message" id="statusMessage" style="display: none;"></div>
    </div>

    <!-- Vote Modal -->
    <div class="vote-modal" id="voteModal">
        <div class="modal-content">
            <h3>Cast Your Vote</h3>
            <p>Select participant to vote for:</p>
            <div class="vote-buttons" id="voteButtons">
                <!-- Buttons will be generated here -->
            </div>
            <p><strong>Cost: 0.1 MON per vote</strong></p>
            <button class="btn close-modal" onclick="closeVoteModal()">Close</button>
        </div>
    </div>

    <div class="credit">
        <p>Created by <a href="https://x.com/ega_2ez4crypto" target="_blank">@ega_2ez4crypto</a></p>
    </div>

    <script>
        // Contract configuration - Updated with deployed contract
        const CONTRACT_ADDRESS = '0xa10FC3954BC82F93dD6c19EBAB78289c912EA8d1'; // Deployed contract address
        const CONTRACT_ABI = [
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "voter",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "round",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "matchIndex",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "participant",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    }
                ],
                "name": "VoteCast",
                "type": "event"
            },
            {
                "inputs": [],
                "name": "currentRound",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "getCurrentMatches",
                "outputs": [
                    {
                        "internalType": "uint256[]",
                        "name": "",
                        "type": "uint256[]"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "roundNum",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "matchNum",
                        "type": "uint256"
                    }
                ],
                "name": "getMatch",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "participant1Id",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "participant2Id",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "votes1",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "votes2",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "winnerId",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "startTime",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "endTime",
                        "type": "uint256"
                    },
                    {
                        "internalType": "bool",
                        "name": "finished",
                        "type": "bool"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "id",
                        "type": "uint256"
                    }
                ],
                "name": "getParticipant",
                "outputs": [
                    {
                        "internalType": "string",
                        "name": "name",
                        "type": "string"
                    },
                    {
                        "internalType": "bool",
                        "name": "active",
                        "type": "bool"
                    },
                    {
                        "internalType": "uint256",
                        "name": "totalVotes",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "getParticipantCount",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "getRoundCount",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "getTournamentState",
                "outputs": [
                    {
                        "internalType": "enum TournamentVoting.TournamentState",
                        "name": "tournamentState",
                        "type": "uint8"
                    },
                    {
                        "internalType": "uint256",
                        "name": "round",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "totalRounds",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "owner",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "name": "participants",
                "outputs": [
                    {
                        "internalType": "string",
                        "name": "name",
                        "type": "string"
                    },
                    {
                        "internalType": "bool",
                        "name": "active",
                        "type": "bool"
                    },
                    {
                        "internalType": "uint256",
                        "name": "totalVotes",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "ROUND_DURATION",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "name": "rounds",
                "outputs": [
                    {
                        "internalType": "bool",
                        "name": "finished",
                        "type": "bool"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "state",
                "outputs": [
                    {
                        "internalType": "enum TournamentVoting.TournamentState",
                        "name": "",
                        "type": "uint8"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "treasury",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "name": "userVotes",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "VOTE_COST",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            }
        ];
        
        const MONAD_TESTNET = {
            chainId: '0x279F', // 10143 in hex
            chainName: 'Monad Testnet',
            rpcUrls: ['https://testnet-rpc.monad.xyz'],
            nativeCurrency: {
                name: 'MON',
                symbol: 'MON',
                decimals: 18
            }
        };

        let web3;
        let contract;
        let account;
        let tournamentData = {
            participants: [
                'LUMITERRA', 'KURU EXCHANGE', 'KIZZY MOBILE', 'CRYSTAL',
                'CULT', 'aPriori', 'Magma', 'O.LAB'
            ],
            currentRound: 0,
            rounds: []
        };

        // Initialize on page load
        window.addEventListener('load', async function() {
            if (typeof window.ethereum !== 'undefined') {
                web3 = new Web3(window.ethereum);
                await checkConnection();
                setupContract();
                
                // Initial tournament update
                setTimeout(() => {
                    updateTournament();
                }, 1000);
            } else {
                showStatus('Please install MetaMask to use this application!', 'error');
            }
            
            generateInitialBracket();
            
            // Update tournament every 15 seconds
            setInterval(updateTournament, 15000);
        });

        async function checkConnection() {
            try {
                const accounts = await ethereum.request({ method: 'eth_accounts' });
                if (accounts.length > 0) {
                    account = accounts[0];
                    updateWalletDisplay();
                    await updateBalance();
                }
            } catch (error) {
                console.error('Error checking connection:', error);
            }
        }

        async function connectWallet() {
            try {
                showStatus('Connecting wallet...', 'info');
                
                // Request account access
                const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
                account = accounts[0];
                
                // Switch to Monad testnet
                try {
                    await ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: MONAD_TESTNET.chainId }],
                    });
                } catch (switchError) {
                    if (switchError.code === 4902) {
                        // Chain not added yet, add it
                        try {
                            await ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [MONAD_TESTNET],
                            });
                        } catch (addError) {
                            throw addError;
                        }
                    } else {
                        throw switchError;
                    }
                }
                
                updateWalletDisplay();
                await updateBalance();
                setupContract();
                
                showStatus('Wallet connected successfully to Monad testnet!', 'success');
                
                // Update tournament after connection
                setTimeout(() => {
                    updateTournament();
                }, 1000);
                
            } catch (error) {
                console.error('Error connecting wallet:', error);
                showStatus('Failed to connect wallet: ' + error.message, 'error');
            }
        }

        function setupContract() {
            if (CONTRACT_ADDRESS && web3) {
                contract = new web3.eth.Contract(CONTRACT_ABI, CONTRACT_ADDRESS);
                console.log('Contract initialized:', CONTRACT_ADDRESS);
            }
        }

        function updateWalletDisplay() {
            const addressElement = document.getElementById('walletAddress');
            const connectButton = document.getElementById('connectWallet');
            
            if (account) {
                addressElement.textContent = `${account.substring(0, 6)}...${account.substring(38)}`;
                connectButton.textContent = 'Connected';
                connectButton.disabled = true;
            }
        }

        async function updateBalance() {
            if (account && web3) {
                try {
                    const balance = await web3.eth.getBalance(account);
                    const balanceInEther = web3.utils.fromWei(balance, 'ether');
                    document.getElementById('balance').textContent = `${parseFloat(balanceInEther).toFixed(4)} MON`;
                } catch (error) {
                    console.error('Error getting balance:', error);
                }
            }
        }

        function generateInitialBracket() {
            const bracket = document.getElementById('bracket');
            
            // Round 1 (Quarterfinals)
            const round1 = createRound('Quarterfinals', [
                { p1: 0, p2: 1, p1Name: 'LUMITERRA', p2Name: 'KURU EXCHANGE' },
                { p1: 2, p2: 3, p1Name: 'KIZZY MOBILE', p2Name: 'CRYSTAL' },
                { p1: 4, p2: 5, p1Name: 'CULT', p2Name: 'aPriori' },
                { p1: 6, p2: 7, p1Name: 'Magma', p2Name: 'O.LAB' }
            ]);
            
            // Round 2 (Semifinals)
            const round2 = createRound('Semifinals', [
                { p1: null, p2: null, p1Name: 'TBD', p2Name: 'TBD' },
                { p1: null, p2: null, p1Name: 'TBD', p2Name: 'TBD' }
            ]);
            
            // Round 3 (Final)
            const round3 = createRound('Final', [
                { p1: null, p2: null, p1Name: 'TBD', p2Name: 'TBD' }
            ]);
            
            bracket.appendChild(round1);
            bracket.appendChild(round2);
            bracket.appendChild(round3);
        }

        function createRound(title, matches) {
            const round = document.createElement('div');
            round.className = 'round';
            
            const titleEl = document.createElement('h3');
            titleEl.textContent = title;
            round.appendChild(titleEl);
            
            matches.forEach((match, index) => {
                const matchEl = document.createElement('div');
                matchEl.className = 'match active';
                matchEl.innerHTML = `
                    <div class="timer" id="timer-${title}-${index}">24:00:00</div>
                    <div class="participant" onclick="openVoteModal(${match.p1}, '${match.p1Name}', '${title}', ${index})">
                        <span class="participant-name">${match.p1Name}</span>
                        <span class="votes" id="votes-${title}-${index}-1">0</span>
                    </div>
                    <div class="participant" onclick="openVoteModal(${match.p2}, '${match.p2Name}', '${title}', ${index})">
                        <span class="participant-name">${match.p2Name}</span>
                        <span class="votes" id="votes-${title}-${index}-2">0</span>
                    </div>
                `;
                round.appendChild(matchEl);
            });
            
            return round;
        }

        let currentVoteData = {};

        function openVoteModal(participantId, participantName, round, matchIndex) {
            if (!account) {
                showStatus('Please connect your wallet first!', 'error');
                return;
            }
            
            currentVoteData = { participantId, participantName, round, matchIndex };
            
            const modal = document.getElementById('voteModal');
            const voteButtons = document.getElementById('voteButtons');
            
            voteButtons.innerHTML = `
                <button class="vote-btn" onclick="castVote()">
                    Vote for ${participantName}
                </button>
            `;
            
            modal.style.display = 'flex';
        }

        function closeVoteModal() {
            document.getElementById('voteModal').style.display = 'none';
        }

        async function castVote() {
            if (!account) {
                showStatus('Please connect your wallet first!', 'error');
                return;
            }

            if (!contract) {
                showStatus('Contract not available. Please check your connection to Monad testnet.', 'error');
                return;
            }
            
            try {
                showStatus('Processing vote... Please confirm the transaction in your wallet.', 'info');
                
                const roundNum = getCurrentRoundNumber(currentVoteData.round);
                const voteValue = web3.utils.toWei('0.1', 'ether');
                
                // Check balance first
                const balance = await web3.eth.getBalance(account);
                const balanceInEther = parseFloat(web3.utils.fromWei(balance, 'ether'));
                
                if (balanceInEther < 0.11) { // Need slightly more than 0.1 for gas
                    showStatus('Insufficient balance. You need at least 0.11 MON (0.1 for vote + gas)', 'error');
                    return;
                }

                // Estimate gas first
                const gasEstimate = await contract.methods.vote(
                    roundNum,
                    currentVoteData.matchIndex,
                    currentVoteData.participantId
                ).estimateGas({
                    from: account,
                    value: voteValue
                });

                console.log('Gas estimate:', gasEstimate);

                const tx = await contract.methods.vote(
                    roundNum,
                    currentVoteData.matchIndex,
                    currentVoteData.participantId
                ).send({
                    from: account,
                    value: voteValue,
                    gas: Math.floor(gasEstimate * 1.2), // Add 20% buffer
                    gasPrice: web3.utils.toWei('1', 'gwei') // Set reasonable gas price for Monad
                });
                
                console.log('Transaction hash:', tx.transactionHash);
                showStatus('Vote cast successfully! Transaction: ' + tx.transactionHash, 'success');
                closeVoteModal();
                
                // Wait a bit before updating to allow blockchain to process
                setTimeout(() => {
                    updateBalance();
                    updateTournament();
                }, 2000);
                
            } catch (error) {
                console.error('Error casting vote:', error);
                let errorMessage = 'Failed to cast vote: ';
                
                if (error.message.includes('User denied')) {
                    errorMessage += 'Transaction was cancelled by user.';
                } else if (error.message.includes('insufficient funds')) {
                    errorMessage += 'Insufficient funds for transaction.';
                } else if (error.message.includes('execution reverted')) {
                    errorMessage += 'Transaction reverted. Match may be finished or invalid.';
                } else {
                    errorMessage += error.message;
                }
                
                showStatus(errorMessage, 'error');
            }
        }

        function getCurrentRoundNumber(roundName) {
            switch (roundName) {
                case 'Quarterfinals': return 0;
                case 'Semifinals': return 1;
                case 'Final': return 2;
                default: return 0;
            }
        }

        async function updateTournament() {
            if (!contract) {
                console.log('Contract not initialized, using demo mode');
                simulateTournamentProgress();
                return;
            }
            
            try {
                // Check if contract is properly deployed
                const code = await web3.eth.getCode(CONTRACT_ADDRESS);
                if (code === '0x') {
                    console.log('Contract not deployed, using demo mode');
                    simulateTournamentProgress();
                    return;
                }

                const state = await contract.methods.getTournamentState().call();
                
                document.getElementById('currentRound').textContent = getRoundName(state.round);
                document.getElementById('tournamentStatus').textContent = getTournamentStatusText(state.tournamentState);
                
                // Update current round display
                const currentRoundNum = parseInt(state.round);
                if (currentRoundNum >= 0 && currentRoundNum <= 2) {
                    const roundNames = ['Quarterfinals', 'Semifinals', 'Final'];
                    const matchCount = currentRoundNum === 0 ? 4 : (currentRoundNum === 1 ? 2 : 1);
                    
                    // Update match data for current round
                    for (let i = 0; i < matchCount; i++) {
                        try {
                            const match = await contract.methods.getMatch(currentRoundNum, i).call();
                            updateMatchDisplay(currentRoundNum, i, match);
                        } catch (error) {
                            console.error(`Error getting match ${i} for round ${currentRoundNum}:`, error);
                        }
                    }
                }
                
            } catch (error) {
                console.error('Error updating tournament:', error);
                // Fallback to simulation if contract calls fail
                simulateTournamentProgress();
            }
        }

        function simulateTournamentProgress() {
            // This simulates the tournament for demo purposes
            const now = Date.now();
            const roundDuration = 24 * 60 * 60 * 1000; // 24 hours in ms
            
            // Simulate vote counts increasing over time
            const matches = document.querySelectorAll('.match');
            matches.forEach((match, index) => {
                const votes1 = match.querySelector('.votes[id*="-1"]');
                const votes2 = match.querySelector('.votes[id*="-2"]');
                
                if (votes1 && votes2) {
                    const currentVotes1 = parseInt(votes1.textContent) || 0;
                    const currentVotes2 = parseInt(votes2.textContent) || 0;
                    
                    // Randomly add votes
                    if (Math.random() < 0.1) { // 10% chance per update
                        if (Math.random() < 0.5) {
                            votes1.textContent = currentVotes1 + Math.floor(Math.random() * 3) + 1;
                        } else {
                            votes2.textContent = currentVotes2 + Math.floor(Math.random() * 3) + 1;
                        }
                    }
                }
            });
            
            updateTimers();
        }

        function updateTimers() {
            const timers = document.querySelectorAll('.timer');
            timers.forEach(timer => {
                if (!timer.classList.contains('finished')) {
                    const currentTime = timer.textContent;
                    const [hours, minutes, seconds] = currentTime.split(':').map(Number);
                    
                    let totalSeconds = hours * 3600 + minutes * 60 + seconds;
                    totalSeconds = Math.max(0, totalSeconds - 10); // Decrease by 10 seconds
                    
                    if (totalSeconds === 0) {
                        timer.textContent = 'FINISHED';
                        timer.classList.add('finished');
                        timer.parentElement.classList.remove('active');
                        timer.parentElement.classList.add('finished');
                        
                        // Determine winner
                        const participants = timer.parentElement.querySelectorAll('.participant');
                        const votes1 = parseInt(participants[0].querySelector('.votes').textContent);
                        const votes2 = parseInt(participants[1].querySelector('.votes').textContent);
                        
                        if (votes1 > votes2) {
                            participants[0].classList.add('winner');
                        } else if (votes2 > votes1) {
                            participants[1].classList.add('winner');
                        } else {
                            participants[0].classList.add('winner'); // Tie-breaker
                        }
                    } else {
                        const newHours = Math.floor(totalSeconds / 3600);
                        const newMinutes = Math.floor((totalSeconds % 3600) / 60);
                        const newSecs = totalSeconds % 60;
                        
                        timer.textContent = `${newHours.toString().padStart(2, '0')}:${newMinutes.toString().padStart(2, '0')}:${newSecs.toString().padStart(2, '0')}`;
                    }
                }
            });
        }

        function updateMatchDisplay(roundNum, matchIndex, matchData) {
            const roundName = getRoundName(roundNum);
            const votes1Element = document.getElementById(`votes-${roundName}-${matchIndex}-1`);
            const votes2Element = document.getElementById(`votes-${roundName}-${matchIndex}-2`);
            const timerElement = document.getElementById(`timer-${roundName}-${matchIndex}`);
            
            if (votes1Element) votes1Element.textContent = matchData.votes1;
            if (votes2Element) votes2Element.textContent = matchData.votes2;
            
            if (matchData.finished && timerElement) {
                timerElement.textContent = 'FINISHED';
                timerElement.classList.add('finished');
                
                const matchElement = timerElement.parentElement;
                matchElement.classList.remove('active');
                matchElement.classList.add('finished');
                
                // Highlight winner
                const participants = matchElement.querySelectorAll('.participant');
                if (matchData.winnerId === matchData.participant1Id) {
                    participants[0].classList.add('winner');
                } else {
                    participants[1].classList.add('winner');
                }
            }
        }

        function getRoundName(roundNum) {
            switch (parseInt(roundNum)) {
                case 0: return 'Quarterfinals';
                case 1: return 'Semifinals';
                case 2: return 'Final';
                default: return 'Unknown';
            }
        }

        function getTournamentStatusText(state) {
            switch (parseInt(state)) {
                case 0: return 'Setup';
                case 1: return 'Ongoing';
                case 2: return 'Finished';
                default: return 'Unknown';
            }
        }

        function showStatus(message, type) {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
            
            statusDiv.style.background = type === 'error' ? 'rgba(255, 107, 107, 0.8)' :
                                      type === 'success' ? 'rgba(76, 175, 80, 0.8)' :
                                      'rgba(255, 255, 255, 0.1)';
            
            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 5000);
        }

        // Event listeners
        document.getElementById('connectWallet').addEventListener('click', connectWallet);

        // Handle account changes
        if (window.ethereum) {
            ethereum.on('accountsChanged', function (accounts) {
                if (accounts.length === 0) {
                    account = null;
                    document.getElementById('walletAddress').textContent = 'Not connected';
                    document.getElementById('connectWallet').textContent = 'Connect Wallet';
                    document.getElementById('connectWallet').disabled = false;
                } else {
                    account = accounts[0];
                    updateWalletDisplay();
                    updateBalance();
                }
            });

            ethereum.on('chainChanged', function (chainId) {
                if (chainId !== MONAD_TESTNET.chainId) {
                    showStatus('Please switch to Monad Testnet', 'error');
                }
            });
        }

        // WebSocket simulation for real-time updates
        function simulateWebSocketUpdates() {
            setInterval(() => {
                if (Math.random() < 0.3) { // 30% chance of update
                    const event = {
                        type: 'voteUpdate',
                        round: Math.floor(Math.random() * 3),
                        match: Math.floor(Math.random() * 4),
                        participant: Math.floor(Math.random() * 8),
                        votes: Math.floor(Math.random() * 50) + 1
                    };
                    
                    // Simulate receiving real-time vote updates
                    console.log('Real-time update:', event);
                }
            }, 15000); // Every 15 seconds
        }

        // Start WebSocket simulation
        simulateWebSocketUpdates();

        // Auto-advance logic simulation
        function checkAutoAdvance() {
            const finishedMatches = document.querySelectorAll('.match.finished');
            const activeMatches = document.querySelectorAll('.match.active');
            
            if (activeMatches.length === 0 && finishedMatches.length > 0) {
                // All matches in current round are finished
                console.log('Round finished, advancing to next round...');
                
                // This would trigger the smart contract's auto-advance
                setTimeout(() => {
                    advanceToNextRound();
                }, 2000);
            }
        }

        function advanceToNextRound() {
            // Simulate advancing to the next round
            showStatus('Round completed! Advancing to next round...', 'success');
            
            // In a real implementation, this would:
            // 1. Call smart contract to advance round
            // 2. Update bracket with winners
            // 3. Start new voting period
            
            // For demo, we'll update the display
            updateBracketForNextRound();
        }

        function updateBracketForNextRound() {
            // Get winners from current round
            const winners = document.querySelectorAll('.participant.winner .participant-name');
            
            if (winners.length >= 2) {
                // Update semifinals or final with winners
                const tbdElements = document.querySelectorAll('.participant-name');
                let tbdCount = 0;
                
                tbdElements.forEach(element => {
                    if (element.textContent === 'TBD' && tbdCount < winners.length) {
                        element.textContent = winners[tbdCount].textContent;
                        element.parentElement.onclick = () => {
                            // Update onclick handler for new participant
                            const participantId = Array.from(document.querySelectorAll('.participant-name'))
                                .indexOf(element);
                            openVoteModal(participantId, element.textContent, 'Semifinals', 0);
                        };
                        tbdCount++;
                    }
                });
                
                // Reset timers for new round
                const newTimers = document.querySelectorAll('.round:not(:first-child) .timer:not(.finished)');
                newTimers.forEach(timer => {
                    timer.textContent = '24:00:00';
                    timer.classList.remove('finished');
                    timer.parentElement.classList.add('active');
                    timer.parentElement.classList.remove('finished');
                });
            }
        }

        // Periodic check for auto-advance
        setInterval(checkAutoAdvance, 30000); // Every 30 seconds

        // Tournament management functions
        async function startTournament() {
            if (!contract) {
                showStatus('Contract not available!', 'error');
                return;
            }
            
            if (!account) {
                showStatus('Please connect your wallet first!', 'error');
                return;
            }
            
            try {
                showStatus('Starting tournament... Please confirm the transaction.', 'info');
                
                const gasEstimate = await contract.methods.startTournament().estimateGas({ from: account });
                
                const tx = await contract.methods.startTournament().send({ 
                    from: account,
                    gas: Math.floor(gasEstimate * 1.2)
                });
                
                console.log('Start tournament tx:', tx.transactionHash);
                showStatus('Tournament started successfully!', 'success');
                
                setTimeout(() => {
                    updateTournament();
                }, 2000);
            } catch (error) {
                console.error('Error starting tournament:', error);
                showStatus('Failed to start tournament: ' + error.message, 'error');
            }
        }

        async function forceFinishExpiredMatches() {
            if (!contract || !account) return;
            
            try {
                const gasEstimate = await contract.methods.forceFinishExpiredMatches().estimateGas({ from: account });
                
                const tx = await contract.methods.forceFinishExpiredMatches().send({ 
                    from: account,
                    gas: Math.floor(gasEstimate * 1.2)
                });
                
                console.log('Force finish tx:', tx.transactionHash);
                showStatus('Expired matches finished!', 'success');
                
                setTimeout(() => {
                    updateTournament();
                }, 2000);
            } catch (error) {
                console.error('Error finishing expired matches:', error);
            }
        }

        // Call this periodically to finish expired matches
        setInterval(forceFinishExpiredMatches, 60000); // Every minute
    </script>
</body>
</html>inputs": [
                    {
                        "internalType": "uint256",
                        "name": "roundNum",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "matchNum",
                        "type": "uint256"
                    }
                ],
                "name": "finishMatch",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "forceFinishExpiredMatches",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "stateMutability": "nonpayable",
                "type": "constructor"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "round",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "matchIndex",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "winner",
                        "type": "uint256"
                    }
                ],
                "name": "MatchFinished",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "round",
                        "type": "uint256"
                    }
                ],
                "name": "RoundFinished",
                "type": "event"
            },
            {
                "inputs": [],
                "name": "startTournament",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "winner",
                        "type": "uint256"
                    }
                ],
                "name": "TournamentFinished",
                "type": "event"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "roundNum",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "matchNum",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "participantId",
                        "type": "uint256"
                    }
                ],
                "name": "vote",
                "outputs": [],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "
